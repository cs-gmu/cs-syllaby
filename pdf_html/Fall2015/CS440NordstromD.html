
<!-- saved from url=(0062)http://cs.gmu.edu/syllabus/syllabi-fall15/CS440NordstromD.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><title>CS 440</title></head><body><h2>
<center>
<br>CS 440
<br>Language Processors
<br>Fall 2015
</center>
</h2>

<b>Dr. David Nordstrom</b><br>
<b>office:</b> 5345 Nguyen Engineering Bldg.<br>
<b>email:</b> dnordstr_AT_gmu_DOT_edu<br>
<b>phone</b> (703) 993-1565<br>
<b>office hours:</b> Monday 10:30 - 11:30, Tuesday 3:00 - 4:00, Wednesday 1:30 - 2:30. 
and by appointment<br>

<br>The course website is at <a href="http://cs.gmu.edu/~dnordstr/cs440">
http://cs.gmu.edu/~dnordstr/cs440 </a>

<h3>Texts</h3>

Aho, Lam, Sethi, and Ullman, <em>Compilers: Principles, Techniques, &amp;
Tools</em>, 2<sup>nd</sup> ed., 2007, Addison-Wesley, 1986.
<br>Levine<em>, flex &amp; bison;
bison</em>, O'Reilly &amp; Associates, 2009.

<h3>Description</h3>

This is a 3-credit course on programming language translation
concentrating on compilers.  Prerequisites are grade of C or better in CS 310, CS 330
and CS 367.  Students should know basic data structures, should have
seen finite automata (finite state machines) and context-free grammars
from CS 330, should be comfortable with assembly language programming
and should be able to program in C.  Topics include:

<blockquote>
Compiler organization<br>
Regular expressions and finite automata<br>
Lexical analysis<br>
Symbol tables<br>
Context-free grammars<br>
LL and LR parsing<br>
lex and yacc<br>
Code generation<br>
Attribute grammars
</blockquote>

There will be a significant programming project in which students
write a small interpreter and a compiler.  Programming will be done in
C and will use the tools lex and yacc or their equivalents.


<h3>Course Outcomes</h3>

Students will:
<ul>

<li>be able to compare compiled and interpreted execution models, outlining the relative merits of each.
</li><li>be able to describe the phases of program translation from source code to executable code and the files produced by these phases.
</li><li>be able to write regular expressions and finite state automata for languages, be able to use tools to automatically generate scanners.
</li><li>understand the definition of grammars; be able to write grammar for context-free languages; be able to manually write recursive-descent parsers; be able to transform grammars and use automatic tools to generate bottom-up parsers.
</li><li>be able to construct and maintain symbol table; be able to process declarations and scopes; understand the type system and type checking.
</li><li>be able to describe the storage system and explain the implementation of high-level language features like function calls.
</li><li>be able to explain the major problems and solutions of code generation; be able to implement code generator from intermediate code.
</li><li>be able to explain important optimization schemes; be able to describe and apply data-flow analysis.
</li></ul>


<h3>Grading</h3>

In addition to the programming project there will be a midterm and a
final exam.  Makeups on exams will not be given except for very good
reason (as judged by me) and only when arranged in advance.  The
course grade will be computed from:

<dl><dt></dt><dd>Programming:    35%
</dd><dt></dt><dd>Midterm:                30%
</dd><dt></dt><dd>Final:          35%
</dd></dl>

</body></html>